### Index

- [Index](#index)
- [Overview](#overview)
- [Retrieve the total number of products in each category](#retrieve-the-total-number-of-products-in-each-category)
  - [Description](#description)
  - [Initial Query](#initial-query)
  - [Optimization Techniques](#optimization-techniques)
  - [Optimized Query](#optimized-query)
- [Identify Top Customers by Total Spending](#identify-top-customers-by-total-spending)
  - [Description](#description-1)
  - [Initial Query](#initial-query-1)
  - [Optimization Techniques](#optimization-techniques-1)
  - [Optimized Query](#optimized-query-1)
- [Retrieve the 1000 Most Recent Orders with Customer Details](#retrieve-the-1000-most-recent-orders-with-customer-details)
  - [Description](#description-2)
  - [Initial Query](#initial-query-2)
  - [Optimization Techniques](#optimization-techniques-2)
  - [Optimized Query](#optimized-query-2)
- [List Products with Low Stock](#list-products-with-low-stock)
  - [Description](#description-3)
  - [Initial Query](#initial-query-3)
  - [Optimization Techniques](#optimization-techniques-3)
  - [Optimized Query](#optimized-query-3)
- [Calculate Revenue Generated by Product Categories](#calculate-revenue-generated-by-product-categories)
  - [Description](#description-4)
  - [Initial Query](#initial-query-4)
  - [Optimization Techniques](#optimization-techniques-4)
  - [Optimized Query](#optimized-query-4)
- [Generate Daily Revenue Report](#generate-daily-revenue-report)
  - [Description](#description-5)
  - [Initial Query](#initial-query-5)
  - [Optimization Techniques](#optimization-techniques-5)
  - [Optimized Query](#optimized-query-5)
- [Monthly Top-Selling Products](#monthly-top-selling-products)
  - [Description](#description-6)
  - [Initial Query](#initial-query-6)
  - [Optimization Techniques](#optimization-techniques-6)
  - [Optimized Query](#optimized-query-6)
- [Customers with Orders Over $500](#customers-with-orders-over-500)
  - [Description](#description-7)
  - [Initial Query](#initial-query-7)
  - [Optimization Techniques](#optimization-techniques-7)
  - [Optimized Query](#optimized-query-7)
- [Suggest Popular Products in the Same Category for the Same Author](#suggest-popular-products-in-the-same-category-for-the-same-author)
  - [Description](#description-8)
  - [Initial Query](#initial-query-8)
  - [Optimization Techniques](#optimization-techniques-8)
  - [Optimized Query](#optimized-query-8)
- [Filtering Products Based on a Word](#filtering-products-based-on-a-word)
  - [Description](#description-9)
  - [Initial Query](#initial-query-9)
  - [Optimization Techniques](#optimization-techniques-9)
  - [Optimized Query](#optimized-query-9)

---

### Overview

All queries in this document operate on the following dataset:

- 10,000 Customers
- 1,000 Categories
- 15,000 Products
- 5,000,000 Orders
- 10,000,000 Order details

A script for inserting dummy data into each table is available [here](./dummy.md).

---

### Retrieve the total number of products in each category

#### Description

This query counts the number of products assigned to each category. It helps analyze product distribution across categories.

#### Initial Query

```sql
SELECT
    c.category_name,
    COUNT(p.product_category_id) AS total_products
FROM category c
LEFT JOIN product p
    ON c.category_id = p.product_category_id
GROUP BY c.category_id
ORDER BY total_products DESC;
```

**Execution Time:** 9.019 ms

#### Optimization Techniques

- Created an index on `product_category_id` in the `product` table to replace sequence scans with an index-only scan.
- Aggregated product counts in a subquery to minimize the number of rows processed during the `JOIN` operation.

#### Optimized Query

```sql
-- Create an index on product_category_id
CREATE INDEX idx_product_category_id ON product (product_category_id);

SELECT
    c.category_name,
    p.total_products
FROM category c
LEFT JOIN (
    -- Pre-aggregate product table to reduce join complexity
    SELECT
        p1.product_category_id,
        COUNT(p1.product_category_id) AS total_products
    FROM product p1
    GROUP BY p1.product_category_id
) AS p
ON c.category_id = p.product_category_id
ORDER BY total_products DESC;
```

**Execution Time After Optimization:** 2.744 ms

---

### Identify Top Customers by Total Spending

#### Description

This query finds customers who have spent the most by summing their total order values. It is useful for identifying high-value customers.

#### Initial Query

```sql
SELECT
    c.category_name, COUNT(p.product_id) AS total_products
FROM category c
LEFT JOIN product p
    ON c.category_id = p.product_category_id
GROUP BY c.category_id
ORDER BY total_products DESC;
```

**Execution Time:** 5.513 ms

#### Optimization Techniques

- Created an index on `order_customer_id` in the `orders` table to speed up joins.
- Pre-aggregated total spending and sorted results before limiting to the top 10 customers.
- Used a Common Table Expression (CTE) for better readability.
- Created a covering index on `customer` to optimize name retrieval.

#### Optimized Query

```sql
-- Create index on foreign key in orders
CREATE INDEX idx_order_customer_id ON orders(order_customer_id);

-- Create covering index on customer table
CREATE INDEX idx_customer_id_with_name ON customer(customer_id, customer_firstname, customer_lastname);

-- Use CTE to precompute total spending
WITH TopSpenders AS (
SELECT
    o2.order_customer_id,
    SUM(o2.order_total_amount) AS total_spending
FROM orders o2
GROUP BY o2.order_customer_id
ORDER BY total_spending DESC
LIMIT 10)

-- Retrieve top spenders with names
SELECT
    (c.customer_firstname || ' ' || c.customer_lastname) AS fullname, t.total_spending
FROM customer c
INNER JOIN TopSpenders t ON t.order_customer_id = c.customer_id;
```

**Execution Time After Optimization:** 867.979 ms

---

### Retrieve the 1000 Most Recent Orders with Customer Details

#### Description

This query fetches the latest 1000 orders along with customer details, such as name and contact information, sorted by order date in descending order.

#### Initial Query

```sql
SELECT
    c.customer_firstname || ' ' || c.customer_lastname AS fullname,
    o.order_id,
    o.order_date
FROM customer c
INNER JOIN orders o
    ON o.order_customer_id = c.customer_id
ORDER BY o.order_date DESC
LIMIT 1000;
```

**Execution Time:** 953.956 ms

#### Optimization Techniques

- Created a covering index on `customer_id` including first and last name.
- Created an index on `order_date` to optimize sorting.
- Indexed `order_customer_id` to speed up the join.

#### Optimized Query

```sql
CREATE INDEX idx_customer_id_with_name ON customer(customer_id, customer_firstname, customer_lastname);
CREATE INDEX idx_orders_order_date ON orders (order_date);
CREATE INDEX idx_orders_customer ON orders(order_customer_id);
```

**Execution Time After Optimization:** 3.620 ms

---

### List Products with Low Stock

#### Description

This query retrieves products where stock levels are below a predefined threshold. It helps businesses identify items that need restocking.

#### Initial Query

```sql
SELECT
    p.product_name,
    p.product_stock_quantity
FROM product p
WHERE p.product_stock_quantity < 10;
```

**Execution Time:** 18.324 ms

#### Optimization Techniques

- Created an index on `product_stock_quantity` to optimize filtering.

#### Optimized Query

```sql
CREATE INDEX idx_product_stock_quantity ON product(product_stock_quantity);
```

**Execution Time After Optimization:** 0.987 ms

---

### Calculate Revenue Generated by Product Categories

#### Description

This query calculates total revenue per product category by summing the revenue from all products in each category.

#### Initial Query

```sql
SELECT
    c.category_name,
    SUM(so.sales_quantity * so.sales_unit_price) AS total_revenue
FROM category c
LEFT JOIN product p ON c.category_id = p.product_category_id
LEFT JOIN sales_order so ON so.sales_product_id = p.product_id
INNER JOIN orders o ON so.sales_order_id = o.order_id
GROUP BY c.category_id;
```

**Execution Time:** 5210.034 ms

#### Optimization Techniques

- Pre-aggregated revenue data in a CTE to reduce join complexity.
- Used a Materialized View (MV) for faster reporting.

#### Optimized Query

```sql
-- Create materialized view for category revenue
CREATE MATERIALIZED VIEW category_revenue_mv AS (
SELECT
    p.product_category_id AS category_id,
    SUM(so.sales_quantity * so.sales_unit_price) AS total_revenue
FROM sales_order so
INNER JOIN product p ON so.sales_product_id = p.product_id
GROUP BY p.product_category_id);

-- Query the materialized view
SELECT
    c.category_name,
    cmv.total_revenue
FROM category c
INNER JOIN category_revenue_mv cmv ON c.category_id = cmv.category_id;
```

**Execution Time After Optimization:** 0.379 ms

---

### Generate Daily Revenue Report

#### Description

This query generates a report showing the total revenue for specific day, helping businesses track daily sales performance.

#### Initial Query

```sql
SELECT
    COUNT(*) AS orders_count,
    SUM(o.order_total_amount) AS revenue
FROM orders o
WHERE o.order_date BETWEEN '2024-01-01 00:00:00' AND '2024-01-01 23:59:59';
```

**Execution Time:** 5.240 ms

#### Optimization Techniques

- Created a covering index on `order_date` including `order_total_amount`.

#### Optimized Query

```sql
CREATE INDEX idx_order_date_with_total_amount ON orders (order_date, order_total_amount);
```

**Execution Time After Optimization:** 1.416 ms

---

### Monthly Top-Selling Products

#### Description

This query identifies the best-selling products each month based on the total quantity sold.

#### Initial Query

```sql
select
	p.product_name,
	count(so.sales_product_id) as total_sales
from
	sales_order so
left join orders o on
	so.sales_order_id = o.order_id
left join product p on
	so.sales_product_id = p.product_id
where
	DATE_TRUNC('month',
	o.order_date) = '2024-01-01'::DATE
group by
	p.product_id
order by
	total_sales desc
limit 10;
-- Execution Time: 843.715 ms
```

**Execution Time:** 843.715 ms

#### Optimization Techniques

- Optimize orders Date Filtering by not use _DATE_TRUNC_ as it prevents PostgreSQL from using an index. Instead, and use a range condition instead.

#### Optimized Query

```sql
select
	p.product_name,
	count(so.sales_product_id) as total_sales
from
	sales_order so
left join orders o on
	so.sales_order_id = o.order_id
left join product p on
	so.sales_product_id = p.product_id
where
	--DATE_TRUNC('month',o.order_date) = '2024-01-01'::DATE
	o.order_date between '2024-01-01' and '2024-01-02'
group by
	p.product_id
order by
	total_sales desc
limit 10;

-- Execution Time: 71.798  ms
```

**Execution Time After Optimization:** 71.798 ms

---

### Customers with Orders Over $500

#### Description

This query finds customers who have placed orders with a total value exceeding $500 for specific period. It helps businesses target high-spending customers.

#### Initial Query

```sql
select
	(c.customer_firstname || ' ' || c.customer_lastname) as fullname,
	sum(o.order_total_amount) as total_amount
from
	customer c
inner join orders o on
	c.customer_id = o.order_customer_id
where
	o.order_total_amount > 500
	and
        order_date >= date_trunc('month',
	'2024-01-01'::date)
	and
        order_date < date_trunc('month',
	'2024-01-02'::date)
group by
	fullname
order by
	total_amount desc;
-- Execution Time: 0.062 ms
```

**Execution Time:** 0.062 ms

#### Optimization Techniques

- group by customer_id instead of customer name to make use of index
- beside create covering index on customer with id include name

#### Optimized Query

```sql
select
	(c.customer_firstname || ' ' || c.customer_lastname) as fullname,
	sum(o.order_total_amount) as total_amount
from
	customer c
inner join orders o on
	c.customer_id = o.order_customer_id
where
	o.order_total_amount > 500
	and
        order_date >= date_trunc('month',
	'2024-01-01'::date)
	and
        order_date < date_trunc('month',
	'2024-01-02'::date)
group by
	c.customer_id
order by
	total_amount desc;
-- Execution Time: 0.035 ms
```

**Execution Time After Optimization:** 0.035 ms

---

### Suggest Popular Products in the Same Category for the Same Author

#### Description

This query recommends popular products (based on sales or ratings) from the same category by the same author, which is useful for personalized recommendations.

#### Initial Query

```sql
select
	*
from
	product p
where
	p.product_category_id in (
	select
		distinct (p.product_category_id) as category_id
	from
		orders o
	inner join sales_order so on
		o.order_id = so.sales_order_id
	inner join product p on
		so.sales_product_id = p.product_id
	where
		o.order_customer_id = 7143
)
	and p.product_id not in (
	select
		distinct (p.product_id) as product_id
	from
		orders o
	inner join sales_order so on
		o.order_id = so.sales_order_id
	inner join product p on
		so.sales_product_id = p.product_id
	where
		o.order_customer_id = 7143);
	-- Execution Time: 11.201 ms
```

**Execution Time:** 11.201 ms

#### Optimization Techniques

- use CTE to avoids duplicate Subqueries

#### Optimized Query

```sql
with customer_purchased_products as (
select
	distinct (so.sales_product_id) as product_id,
	p.product_category_id as category_id
from
	orders o
inner join sales_order so on
	o.order_id = so.sales_order_id
inner join product p on
	so.sales_product_id = p.product_id
where
	o.order_customer_id = 7143
)
select
	*
from
	product p
where
	p.product_category_id in (
	select
		x.category_id
	from
		customer_purchased_products x)
	and p.product_id not in (
	select
		x.product_id
	from
		customer_purchased_products x);
-- Execution Time: 8.114 ms
```

**Execution Time After Optimization:** 8.114 ms

---

### Filtering Products Based on a Word

#### Description

This query searches for products whose names, descriptions, or tags contain a specific word, allowing users to find relevant products easily.

#### Initial Query

```sql
select *
from product p
where
	p."name" ilike '%camera%'
or
	p.description ilike '%camera%';
-- Execution Time: 18.314 ms
```

**Execution Time:** 18.314 ms

#### Optimization Techniques

- use a GIN (Generalized Inverted Index) with pg_trgm (PostgreSQL trigram extension).

#### Optimized Query

```sql
-- Enable the pg_trgm Extension
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Create a GIN Index on the Columns
CREATE INDEX idx_product_name_trgm ON product USING GIN (product_name gin_trgm_ops);
CREATE INDEX idx_product_description_trgm ON product USING GIN (product_description gin_trgm_ops);

```

**Execution Time After Optimization:** 12.989 ms
